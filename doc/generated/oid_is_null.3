.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "OID_IS_NULL" "3" "2017-11-07" "NVM Library - pmemobj API version 2.2" "NVML Programmer's Manual"
.hy
.\" Copyright 2014-2017, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]OID_IS_NULL\f[](), \f[B]OID_EQUALS\f[](),
\f[B]pmemobj_direct\f[](), \f[B]pmemobj_oid\f[](),
\f[B]pmemobj_type_num\f[](), \f[B]pmemobj_pool_by_oid\f[](),
\f[B]pmemobj_pool_by_ptr\f[]() \-\- functions that allows mapping
operations between object addresses, object handles, oids or type
numbers
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemobj.h>

OID_IS_NULL(PMEMoid\ oid)
OID_EQUALS(PMEMoid\ lhs,\ PMEMoid\ rhs)

void\ *pmemobj_direct(PMEMoid\ oid);
PMEMoid\ pmemobj_oid(const\ void\ *addr);\ (EXPERIMENTAL)
uint64_t\ pmemobj_type_num(PMEMoid\ oid);
PMEMobjpool\ *pmemobj_pool_by_oid(PMEMoid\ oid);
PMEMobjpool\ *pmemobj_pool_by_ptr(const\ void\ *addr);
\f[]
.fi
.SH DESCRIPTION
.PP
Each object stored in persistent memory pool is represented by an object
handle of type \f[I]PMEMoid\f[].
In practice, such a handle is a unique Object IDentifier (\f[I]OID\f[])
of a global scope, which means that two objects from different pools may
not have the same \f[I]OID\f[].
The special \f[B]OID_NULL\f[] macro defines a NULL\-like handle that
does not represent any object.
The size of a single object is limited by a
\f[B]PMEMOBJ_MAX_ALLOC_SIZE\f[].
Thus an allocation with requested size greater than this value will
fail.
.PP
An \f[I]OID\f[] cannot be considered as a direct pointer to an object.
Each time the program attempts to read or write object data, it must
obtain the current memory address of the object by converting its
\f[I]OID\f[] into the pointer.
.PP
In contrast to the memory address, the \f[I]OID\f[] value for given
object does not change during the life of an object (except for realloc
operation), and remains valid after closing and reopening the pool.
For this reason, if an object contains a reference to another persistent
object \- necessary to build some kind of a linked data structure \- it
shall never use memory address of an object, but its \f[I]OID\f[].
.PP
The \f[B]pmemobj_direct\f[]() function as argument takes object handle
of type \f[I]PMEMoid\f[] to get pointer to an object represented by
\f[I]oid\f[].
.PP
The \f[B]pmemobj_oid\f[]() function as argument takes address and search
\f[I]PMEMoid\f[] to an object pointed to by this \f[I]addr\f[].
.PP
The \f[B]pmemobj_type_num\f[]() function takes object handle
\f[I]oid\f[] and returns number of the object represented by this
\f[I]oid\f[].
.PP
The \f[B]pmemobj_pool_by_oid\f[]() function returns a handle to the pool
which contains the object represented by \f[I]oid\f[] passed as argument
to this function.
.PP
The \f[B]pmemobj_pool_by_ptr\f[]() function returns a handle to the pool
which contains the address \f[I]addr\f[].
.PP
At the time of allocation (or reallocation), each object may be assigned
to a number representing its type.
Such a \f[I]type number\f[] may be used to arrange the persistent
objects based on their actual user\-defined structure type, thus
facilitating implementation of a simple run\-time type safety mechanism.
It also allows to iterate through all the objects of given type stored
in the persistent memory pool.
See \f[I]Object containers\f[] section in \f[B]libpmemobj\f[](7) for
more details functions.
.PP
The \f[B]OID_IS_NULL\f[]() macro checks if given \f[I]PMEMoid\f[]
represents a NULL object.
.PP
The \f[B]OID_EQUALS\f[]() macro compares two \f[I]PMEMoid\f[] objects.
.SH RETURN VALUE
.PP
The \f[B]pmemobj_direct\f[]() function returns a pointer to an object
represented by \f[I]oid\f[].
If \f[B]OID_NULL\f[] is passed as an argument, function returns NULL.
.PP
The \f[B]pmemobj_oid\f[]() function returns a \f[I]PMEMoid\f[] to an
object pointed to by \f[I]addr\f[].
If \f[I]addr\f[] is not from within a pmemobj pool, \f[B]OID_NULL\f[] is
returned.
If \f[I]addr\f[] is not the start of an object (does not point to the
beginning of a valid allocation), the resulting \f[I]PMEMoid\f[] can be
safely used only with:
.IP \[bu] 2
\f[B]pmemobj_pool_by_oid()\f[]
.IP \[bu] 2
\f[B]pmemobj_direct()\f[]
.IP \[bu] 2
\f[B]pmemobj_tx_add_range(3)\f[]
.PP
The \f[B]pmemobj_type_num\f[]() function returns a type number of the
object represented by \f[I]oid\f[].
.PP
The \f[B]pmemobj_pool_by_oid\f[]() function returns a handle to the pool
which contains the object represented by \f[I]oid\f[].
If the pool is not open or \f[B]OID_NULL\f[] is passed as an argument,
function returns NULL.
.PP
The \f[B]pmemobj_pool_by_ptr\f[]() function returns a handle to the pool
which contains the address.
If the address does not belong to any open pool, function returns NULL.
.SH NOTES
.PP
For performance reasons, on Linux \f[B]pmemobj_direct\f[]() function is
inlined by default.
You may decide to compile your programs using the non\-inlined variant
of \f[B]pmemobj_direct\f[]() by defining
\f[B]PMEMOBJ_DIRECT_NON_INLINE\f[] macro.
You should define this macro by using \f[I]#define\f[] preprocessor
directive, which must come before \f[I]#include\f[] of
\f[B]<libpmemobj.h>\f[].
You could also use \f[I]\-D\f[] option to gcc.
On Windows \f[B]PMEMOBJ_DIRECT_NON_INLINE\f[] macro has no effect.
.SH SEE ALSO
.PP
\f[B]libpmemobj\f[](7) and \f[B]<http://pmem.io>\f[]
