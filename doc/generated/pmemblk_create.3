.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "PMEMBLK_CREATE" "3" "2017-11-07" "NVM Library - pmemblk API version 1.0" "NVML Programmer's Manual"
.hy
.\" Copyright 2014-2017, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]pmemblk_create\f[](), \f[B]pmemblk_open\f[](),
\f[B]pmemblk_close\f[](), \f[B]pmemblk_check\f[]() \-\- create, open and
close block pool
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemblk.h>

PMEMblkpool\ *pmemblk_create(const\ char\ *path,\ size_t\ bsize,
\ \ \ \ \ \ \ \ size_t\ poolsize,\ mode_t\ mode);
PMEMblkpool\ *pmemblk_open(const\ char\ *path,\ size_t\ bsize);
void\ pmemblk_close(PMEMblkpool\ *pbp);
int\ pmemblk_check(const\ char\ *path,\ size_t\ bsize);
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[B]pmemblk_create\f[]() function creates a block memory pool with
the given total \f[I]poolsize\f[] divided up into as many elements of
size \f[I]bsize\f[] as will fit in the pool.
Since the transactional nature of a block memory pool requires some
space overhead in the memory pool, the resulting number of available
blocks is less than \f[I]poolsize\f[]/\f[I]bsize\f[], and is made
available to the caller via the \f[B]pmemblk_nblock\f[](3) function.
Given the specifics of the implementation, the number of available
blocks for the user cannot be less than 256.
This translates to at least 512 internal blocks.
\f[I]path\f[] specifies the name of the memory pool file to be created.
\f[I]mode\f[] specifies the permissions to use when creating the file as
described by \f[B]creat\f[](2).
The memory pool file is fully allocated to the size \f[I]poolsize\f[]
using \f[B]posix_fallocate\f[](3).
The caller may choose to take responsibility for creating the memory
pool file by creating it before calling \f[B]pmemblk_create\f[]() and
then specifying \f[I]poolsize\f[] as zero.
In this case \f[B]pmemblk_create\f[]() will take the pool size from the
size of the existing file and will verify that the file appears to be
empty by searching for any non\-zero data in the pool header at the
beginning of the file.
The net pool size of a pool file is equal to the file size.
The minimum net pool size allowed by the library for a block pool is
defined in \f[B]<libpmemblk.h>\f[] as \f[B]PMEMBLK_MIN_POOL\f[].
\f[I]bsize\f[] can be any non\-zero value, however \f[B]libpmemblk\f[]
will silently round up the given size to \f[B]PMEMBLK_MIN_BLK\f[], as
defined in \f[B]<libpmemblk.h>\f[].
.PP
Depending on the configuration of the system, the available space of
non\-volatile memory space may be divided into multiple memory devices.
In such case, the maximum size of the pmemblk memory pool could be
limited by the capacity of a single memory device.
The \f[B]libpmemblk\f[](7) allows building persistent memory resident
array spanning multiple memory devices by creation of persistent memory
pools consisting of multiple files, where each part of such a \f[I]pool
set\f[] may be stored on different pmem\-aware filesystem.
.PP
Creation of all the parts of the pool set can be done with the
\f[B]pmemblk_create\f[]() function.
However, the recommended method for creating pool sets is to do it by
using the \f[B]pmempool\f[](1) utility.
.PP
When creating the pool set consisting of multiple files, the
\f[I]path\f[] argument passed to \f[B]pmemblk_create\f[]() must point to
the special \f[I]set\f[] file that defines the pool layout and the
location of all the parts of the pool set.
The \f[I]poolsize\f[] argument must be 0.
The meaning of \f[I]layout\f[] and \f[I]mode\f[] arguments doesn\[aq]t
change, except that the same \f[I]mode\f[] is used for creation of all
the parts of the pool set.
.PP
Poolset file format in more details is describe in \f[B]poolset\f[](5).
.PP
The \f[B]pmemblk_open\f[]() function opens an existing block memory
pool.
The \f[I]path\f[] argument must be an existing file containing a block
memory pool as created by \f[B]pmemblk_create\f[]().
The application must have permission to open the file and memory map it
with read/write permissions.
If the \f[I]bsize\f[] provided is non\-zero, \f[B]pmemblk_open\f[]()
will verify the given block size matches the block size used when the
pool was created.
Otherwise, \f[B]pmemblk_open\f[]() will open the pool without
verification of the block size.
The \f[I]bsize\f[] can be determined using the \f[B]pmemblk_bsize\f[](3)
function.
When opening the pool set consisting of multiple files, the
\f[I]path\f[] argument passed to \f[B]pmemblk_open\f[]() must not point
to the pmemblk memory pool file, but to the same \f[I]set\f[] file that
was used for the pool set creation.
.PP
The \f[B]pmemblk_close\f[]() function closes the memory pool indicated
by \f[I]pbp\f[] and deletes the memory pool handle.
The block memory pool itself lives on in the file that contains it and
may be re\-opened at a later time using \f[B]pmemblk_open\f[]() as
described above.
.PP
The \f[B]pmemblk_check\f[]() function performs a consistency check of
the file indicated by \f[I]path\f[].
and returns 1 if the memory pool is found to be consistent.
Any inconsistencies found will cause \f[B]pmemblk_check\f[]() to return
0, in which case the use of the file with \f[B]libpmemblk\f[] will
result in undefined behavior.
The debug version of \f[B]libpmemblk\f[] will provide additional details
on inconsistencies when \f[B]PMEMBLK_LOG_LEVEL\f[] is at least 1, as
described in the \f[B]DEBUGGING AND ERROR HANDLING\f[] section below.
When \f[I]bsize\f[] is non\-zero \f[B]pmemblk_check\f[]() will compare
it to the block size of the pool and return 0 when they don\[aq]t match.
\f[B]pmemblk_check\f[]() will return \-1 and set \f[I]errno\f[] if it
cannot perform the consistency check due to other errors.
\f[B]pmemblk_check\f[]() opens the given \f[I]path\f[] read\-only so it
never makes any changes to the file.
This function is not supported on Device DAX.
.SH RETURN VALUE
.PP
The \f[B]pmemblk_create\f[]() function returns pointer to block memory
pool or returns NULL and sets \f[I]errno\f[] appropriately if the error
prevents any of the pool set files from being created.
.PP
The \f[B]pmemblk_open\f[]() function returns a memory pool handle used
with most of the functions in \f[B]pmemblk\f[](7) library.
If an error prevents the pool from being opened, \f[B]pmemblk_open\f[]()
returns NULL and sets \f[I]errno\f[] appropriately.
A block size mismatch with the \f[I]bsize\f[] argument passed in results
in \f[I]errno\f[] being set to \f[B]EINVAL\f[].
If an error prevents any of the pool set files from being opened, or if
the actual size of any file does not match the corresponding part size
defined in \f[I]set\f[] file \f[B]pmemblk_open\f[]() returns NULL and
sets \f[I]errno\f[] appropriately.
.PP
The \f[B]pmemblk_close\f[]() function returns no value.
.PP
The \f[B]pmemblk_check\f[]() returns 1 if the memory pool is found to be
consistent.
Any inconsistencies found will cause \f[B]pmemblk_check\f[]() to return
0, in which case the use of the file with \f[B]libpmemblk\f[] will
result in undefined behavior.
The debug version of \f[B]libpmemblk\f[] will provide additional details
on inconsistencies when \f[B]PMEMBLK_LOG_LEVEL\f[] is at least 1.
When \f[I]bsize\f[] is non\-zero \f[B]pmemblk_check\f[]() will compare
it to the block size of the pool and return 0 when they don\[aq]t match.
\f[B]pmemblk_check\f[]() will return \-1 and set \f[I]errno\f[] if it
cannot perform the consistency check due to other errors.
\f[B]pmemblk_check\f[]() opens the given \f[I]path\f[] read\-only so it
never makes any changes to the file.
This function is not supported on Device DAX.
.SH SEE ALSO
.PP
\f[B]pmempool\f[](1), \f[B]posix_fallocate\f[](2), \f[B]pmemblk\f[](7)
and \f[B]<http://pmem.io>\f[]
