.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "PMEMPOOL_CHECK_INIT" "3" "2017-11-07" "NVM Library - pmempool API version 1.1" "NVML Programmer's Manual"
.hy
.\" Copyright 2014-2017, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]pmempool_check_init\f[](), \f[B]pmempool_check\f[](),
\f[B]pmempool_check_end\f[]() \-\- checks pmempool health
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmempool.h>

PMEMpoolcheck\ *pmempool_check_initU(struct\ pmempool_check_argsU\ *args,
\ \ \ \ size_t\ args_size);
PMEMpoolcheck\ *pmempool_check_initW(struct\ pmempool_check_argsW\ *args,
\ \ \ \ size_t\ args_size);
struct\ pmempool_check_statusU\ *pmempool_checkU(PMEMpoolcheck\ *ppc);
struct\ pmempool_check_statusW\ *pmempool_checkW(PMEMpoolcheck\ *ppc);
}{
PMEMpoolcheck\ *pmempool_check_init(struct\ pmempool_check_args\ *args,
\ \ \ \ size_t\ args_size);
struct\ pmempool_check_status\ *pmempool_check(PMEMpoolcheck\ *ppc);
}
enum\ pmempool_check_result\ pmempool_check_end(PMEMpoolcheck\ *ppc);
\f[]
.fi
.SH DESCRIPTION
.PP
To perform check provided by \f[B]libpmempool\f[], a \f[I]check
context\f[] must be first initialized using
\f[B]pmempool_check_init\f[]() function described in this section.
Once initialized \f[I]check context\f[] is represented by an opaque
handle, of type \f[I]PMEMpoolcheck*\f[], which is passed to all of the
other functions available in \f[B]libpmempool\f[]
.PP
To execute check \f[B]pmempool_check\f[]() must be called iteratively.
Each call resumes check till new status will be generated.
Each status is represented by \f[I]struct pmempool_check_status*\f[]
structure.
It may carry various types of messages described in this section.
.PP
When check is completed \f[B]pmempool_check\f[]() returns NULL pointer.
Check must be finalized using \f[B]pmempool_check_end\f[]().
It returns \f[I]enum pmempool_check_result\f[] describing result of the
whole check.
.PP
The \f[B]pmempool_check_init\f[]() initializes check context.
\f[I]args\f[] describes parameters of the check context.
\f[I]args_size\f[] should be equal to the size of the \f[I]struct
pmempool_check_args\f[].
\f[I]struct pmempool_check_args\f[] is defined as follows:
.IP
.nf
\f[C]
struct\ pmempool_check_args
{
\ \ \ \ /*\ path\ to\ the\ pool\ to\ check\ */
\ \ \ \ const\ char\ *path;

\ \ \ \ /*\ optional\ backup\ path\ */
\ \ \ \ const\ char\ *backup_path;

\ \ \ \ /*\ type\ of\ the\ pool\ */
\ \ \ \ enum\ pmempool_pool_type\ pool_type;

\ \ \ \ /*\ parameters\ */
\ \ \ \ int\ flags;
};
\f[]
.fi
.PP
The \f[I]flags\f[] argument accepts any combination of the following
values (ORed):
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_REPAIR\f[] \- perform repairs
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_DRY_RUN\f[] \- emulate repairs, not supported on
Device DAX
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_ADVANCED\f[] \- perform hazardous repairs
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_ALWAYS_YES\f[] \- do not ask before repairs
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_VERBOSE\f[] \- generate info statuses
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_FORMAT_STR\f[] \- generate string format statuses
.PP
\f[I]pool_type\f[] has to match type of the \f[I]pool\f[] being
processed.
You can turn on pool type detection by setting \f[I]pool_type\f[] to
\f[B]PMEMPOOL_POOL_TYPE_DETECT\f[].
Pool type detection fail ends check.
.PP
\f[I]backup_path\f[] argument can either be:
.IP \[bu] 2
NULL.
It indicates no backup will be performed.
.IP \[bu] 2
a non existing file.
It is valid only in case \f[I]path\f[] is a single file \f[I]pool\f[].
It indicates a \f[I]backup_path\f[] file will be created and backup will
be performed.
.IP \[bu] 2
an existing \f[I]pool set\f[] file of the same structure (the same
number of parts with exactly the same size) as the source \f[I]pool
set\f[].
It is valid only in case \f[I]path\f[] is a \f[I]pool set\f[].
It indicates backup will be performed in a form described by the
\f[I]backup_path\f[] \f[I]pool set\f[].
.PP
Backup is supported only if the source \f[I]pool set\f[] has no defined
replicas.
.PP
Pool sets with remote replicas are not supported neither as
\f[I]path\f[] nor as \f[I]backup_path\f[].
.PP
The \f[B]pmempool_check\f[]() function starts or resumes the check
indicated by \f[I]ppc\f[].
When next status will be generated it pauses the check and returns a
pointer to the \f[I]struct pmempool_check_status\f[] structure:
.IP
.nf
\f[C]
struct\ pmempool_check_status
{
\ \ \ \ enum\ pmempool_check_msg_type\ type;\ /*\ type\ of\ the\ status\ */
\ \ \ \ struct
\ \ \ \ {
\ \ \ \ \ \ \ \ const\ char\ *msg;\ /*\ status\ message\ string\ */
\ \ \ \ \ \ \ \ const\ char\ *answer;\ /*\ answer\ to\ message\ if\ applicable\ */
\ \ \ \ }\ str;
};
\f[]
.fi
.PP
This structure can describe three types of statuses:
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_MSG_TYPE_INFO\f[] \- detailed information about the
check.
Generated only if a \f[B]PMEMPOOL_CHECK_VERBOSE\f[] flag was set.
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_MSG_TYPE_ERROR\f[] \- encountered error
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_MSG_TYPE_QUESTION\f[] \- question.
Generated only if an \f[B]PMEMPOOL_CHECK_ALWAYS_YES\f[] flag was not
set.
It requires \f[I]answer\f[] to be set to "yes" or "no" before
continuing.
.PP
After calling \f[B]pmempool_check\f[]() again the previously provided
\f[I]struct pmempool_check_status*\f[] pointer must be considered
invalid.
.PP
The \f[B]pmempool_check_end\f[]() function finalizes the check and
releases all related resources.
\f[I]ppc\f[] is not a valid pointer after calling
\f[B]pmempool_check_end\f[]().
.SH RETURN VALUE
.PP
The \f[B]pmempool_check_init\f[]() returns NULL and sets \f[I]errno\f[]
appropriately if provided parameters are invalid or initialization
process fails, otherwise it returns an opaque handle, of type
\f[I]PMEMpoolcheck*\f[].
.PP
The \f[B]pmempool_check\f[]() returns NULL pointer when the check
completes or returns a pointer to the \f[I]struct
pmempool_check_status\f[] structure described above when next status is
generated.
.PP
The \f[B]pmempool_check_end\f[]() function returns \f[I]enum
pmempool_check_result\f[] summarizing result of the finalized check.
\f[B]pmempool_check_end\f[]() can return one of the following values:
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_RESULT_CONSISTENT\f[] \- the \f[I]pool\f[] is
consistent
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_RESULT_NOT_CONSISTENT\f[] \- the \f[I]pool\f[] is
not consistent
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_RESULT_REPAIRED\f[] \- the \f[I]pool\f[] has issues
but all repair steps completed successfully
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_RESULT_CANNOT_REPAIR\f[] \- the \f[I]pool\f[] has
issues which can not be repaired
.IP \[bu] 2
\f[B]PMEMPOOL_CHECK_RESULT_ERROR\f[] \- the \f[I]pool\f[] has errors or
the check encountered issue
.SH EXAMPLE
.PP
This is an example of a \f[I]check context\f[] initialization:
.IP
.nf
\f[C]
struct\ pmempool_check_args\ args\ =
{
\ \ \ \ .path\ =\ "/path/to/blk.pool",
\ \ \ \ .backup_path\ =\ NULL,
\ \ \ \ .pool_type\ =\ PMEMPOOL_POOL_TYPE_BLK,
\ \ \ \ .flags\ =\ PMEMPOOL_CHECK_REPAIR\ |\ PMEMPOOL_CHECK_DRY_RUN\ |
\ \ \ \ \ \ \ \ PMEMPOOL_CHECK_VERBOSE\ |\ PMEMPOOL_CHECK_FORMAT_STR
};
\f[]
.fi
.IP
.nf
\f[C]
PMEMpoolcheck\ *ppc\ =\ pmempool_check_init(&args,\ sizeof(args));
\f[]
.fi
.PP
The check will process a \f[I]pool\f[] of type
\f[B]PMEMPOOL_POOL_TYPE_BLK\f[] located in the path
\f[I]/path/to/blk.pool\f[].
Before check it will not create a backup of the \f[I]pool\f[]
(\f[I]backup_path == NULL\f[]).
If the check will find any issues it will try to perform repair steps
(\f[B]PMEMPOOL_CHECK_REPAIR\f[]), but it will not make any changes to
the \f[I]pool\f[] (\f[B]PMEMPOOL_CHECK_DRY_RUN\f[]) and it will not
perform any dangerous repair steps (no
\f[B]PMEMPOOL_CHECK_ADVANCED\f[]).
The check will ask before performing any repair steps (no
\f[B]PMEMPOOL_CHECK_ALWAYS_YES\f[]).
It will also generate detailed information about the check
(\f[B]PMEMPOOL_CHECK_VERBOSE\f[]).
\f[B]PMEMPOOL_CHECK_FORMAT_STR\f[] flag indicates string format statuses
(\f[I]struct pmempool_check_status\f[]).
Currently it is the only supported status format so this flag is
required.
.SH NOTES
.PP
Currently, checking the consistency of a \f[I]pmemobj\f[] pool is
\f[B]not\f[] supported.
.SH SEE ALSO
.PP
\f[B]libpmemlog\f[](7), \f[B]libpmemobj\f[](7) and
\f[B]<http://pmem.io>\f[]
