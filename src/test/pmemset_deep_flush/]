// SPDX-License-Identifier: BSD-3-Clause
/* Copyright 2021, Intel Corporation */

/*
 * pmemset_persist.c -- pmemset_part unittests
 */

#include "out.h"
#include "unittest.h"
#include "ut_pmemset_utils.h"

static int pmem2_df_count;

FUNC_MOCK(pmem2_deep_flush, int, struct pmem2_map *map, size_t size)
	FUNC_MOCK_RUN_DEFAULT {
		pmem2_df_count++;
		return _FUNC_REAL(pmem2_deep_flush)(map, size);
	}
FUNC_MOCK_END

static void create_config(struct pmemset_config **cfg) {
	int ret = pmemset_config_new(cfg);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);
	UT_ASSERTne(cfg, NULL);

	ret = pmemset_config_set_required_store_granularity(*cfg,
		PMEM2_GRANULARITY_PAGE);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);
	UT_ASSERTne(cfg, NULL);
}

/*
 * test_deep_flush_single - test pmemset_deep_flush combinations with single map
 */
static int
test_deep_flush_single(const struct test_case *tc, int argc,
		char *argv[])
{
	if (argc < 1)
		UT_FATAL("usage: test_deep_flush_single <path>");

	const char *file = argv[0];
	struct pmemset_part *part;
	struct pmemset_source *src;
	struct pmemset *set;
	struct pmemset_config *cfg;

	int ret = pmemset_source_from_file(&src, file);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);

	create_config(&cfg);

	ret = pmemset_new(&set, cfg);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);

	ret = pmemset_part_new(&part, set, src, 0, 64 * 1024);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);

	struct pmemset_part_descriptor desc;
	ret = pmemset_part_map(&part, NULL, &desc);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);
	UT_ASSERTeq(part, NULL);

	/* flush single part map */
	pmemset_deep_flush(set, desc.addr, desc.size);

	UT_ASSERTeq(pmem2_df_count, 1);
	pmem2_df_count = 0;

	/* flush half of a single part map */
	pmemset_deep_flush(set, desc.addr, desc.size / 2);

	UT_ASSERTeq(pmem2_df_count, 1);
	pmem2_df_count = 0;

	/* flush half of a single part map and out of map */
	pmemset_deep_flush(set, (char *)desc.addr + desc.size / 2, desc.size);

	UT_ASSERTeq(pmem2_df_count, 1);
	pmem2_df_count = 0;

	/* flush out of map */
	pmemset_deep_flush(set, (char *)desc.addr - desc.size, desc.size / 2);

	UT_ASSERTeq(pmem2_df_count, 0);

	ret = pmemset_delete(&set);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);
	ret = pmemset_config_delete(&cfg);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);
	ret = pmemset_source_delete(&src);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);

	return 1;
}

/*
 * test_deep_flush_multiple - test pmemset_deep_flush conbinations on multiple
 * part maps
 */
static int
test_persist_multiple_parts(const struct test_case *tc, int argc,
		char *argv[])
{
	if (argc < 1)
		UT_FATAL("usage: test_deep_flush_multiple <path>");

#define NUM_OF_PARTS 5

	const char *file1 = argv[0];
	struct pmemset_part *part;
	struct pmemset_source *src;
	struct pmemset *set;
	struct pmemset_config *cfg;
	size_t first_part_size = 64 * 1024;
	size_t second_part_size = 128 * 1024;

	struct pmemset_part_descriptor patr_desc[NUM_OF_PARTS];

	int ret = pmemset_source_from_file(&src, file1);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);

	create_config(&cfg);

	ret = pmemset_new(&set, cfg);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);

	for (int i = 0; i < NUM_OF_PARTS; i++) {
		ret = pmemset_part_new(&part, set, src, 0, first_part_size);
		UT_PMEMSET_EXPECT_RETURN(ret, 0);

		ret = pmemset_part_map(&part, NULL, &part_desc[i]);
		UT_PMEMSET_EXPECT_RETURN(ret, 0);
	}


	// pmemset_persist(set, second_desc.addr, second_desc.size);

	ret = pmemset_delete(&set);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);
	ret = pmemset_config_delete(&cfg);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);
	ret = pmemset_source_delete(&src);
	UT_PMEMSET_EXPECT_RETURN(ret, 0);

	return 1;
}


/*
 * test_cases -- available test cases
 */
static struct test_case test_cases[] = {
	TEST_CASE(test_deep_flush_single),
	TEST_CASE(test_persist_multiple_parts),
};

#define NTESTS (sizeof(test_cases) / sizeof(test_cases[0]))

int
main(int argc, char **argv)
{
	START(argc, argv, "pmemset_deep_flush");

	util_init();
	out_init("pmemset_deep_flush", "TEST_LOG_LEVEL", "TEST_LOG_FILE", 0, 0);
	TEST_CASE_PROCESS(argc, argv, test_cases, NTESTS);
	out_fini();

	DONE(NULL);
}
